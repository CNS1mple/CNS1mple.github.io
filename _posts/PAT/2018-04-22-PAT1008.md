---
layout: post
#标题配置
title: "PAT1008.数组元素循环右移问题 (20)"
#时间配置
date:   2018-04-22 18:59:01 +0800
#大类配置
categories: 算法
#小类配置
tag: PAT乙级
---

* content
{:toc}
 

### 题目

=================================================  
一个数组A中存有N（N>0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M>=0）个位置，即将A中的数据由（A0 A1……AN-1）变换为（AN-M …… AN-1 A0 A1……AN-M-1）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？  


输入格式：每个输入包含一个测试用例，第1行输入N ( 1<=N<=100)、M（M>=0）；第2行输入N个整数，之间用空格分隔。  


输出格式：在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。  


### 样例  


=================================================  

输入样例：  

**6 2**  

**1 2 3 4 5 6**  

输出样例：  

**5 6 1 2 3 4**  



  

### 思路

=================================================  

 **这里取巧，并没有swap，而是直接输出即可。
 特别注意M>N的情况。**

### 完整代码

=================================================  
  

  {% highlight ruby %}
#include <bits/stdc++.h>
using namespace std;
int main(){
	int N, M;
	cin  >> N >> M;
	if(N < M){
		M = M % N;
	}
	int s[10005];
	int flag = 0;
	for(int i = 0; i < N; i++){
		cin >> s[i];
	}
	for(int i = N - M; i < N; i++){
		if(i == N - M){
			cout << s[i];
			flag = 1;
		}else{
			cout << " " << s[i];
			flag = 1;
		}	
	}
	for(int i = 0; i < N - M; i++){
		if(flag){
			cout << " " << s[i];
		}else{
			if(i == 0){
				cout << s[i];
			}else{
				cout << " " << s[i];
			}
		}
	}
	return 0;
} 
{% endhighlight %}  
